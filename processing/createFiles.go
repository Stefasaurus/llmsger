/*
Copyright Â© 2024 NAME HERE <EMAIL ADDRESS>
*/
package process

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"
)

const startText = `/** @file %s
* 
* @brief An automatically generated localization file. Generated by llmsger.
*/

#ifndef %s
#define %s

`

const endText = `
#endif /* %s */

/*** end of file ***/
`

const startTextMerged = `/** @file %s
* 
* @brief An automatically generated localization file. Generated by llmsger.
*/

#ifndef %s
#define %s
/*---------------------DEFINE LANGUAGE USED---------------------*/
#define // Define used language
`

const ifdefLangStartMerged = `
/*		%s START		*/
#ifdef %s

`

const ifdefLangEndMerged = `
#endif /* %s */
/*		%s END		*/
`

const endTextMerged = `
#endif /* %s */

/*** end of file ***/
`

const langText = "#define %s\t\t\"%s\"\n"

func CreateFiles(langMap map[string][]string, outDir string) (err error) {
	defer func() {
		if err != nil {
			err = fmt.Errorf("parsing records failed: %w", err)
		}
	}()

	fileInfo, err := os.Stat(outDir)
	if err != nil {
		err = fmt.Errorf("unable to get file information for %s", outDir)
		return err
	}

	if !fileInfo.IsDir() {
		err = fmt.Errorf("output path is not a directory %s", outDir)
		return err
	}

	varNames := langMap["var"]
	if len(varNames) == 0 {
		err = fmt.Errorf("no var fields assigned in input file")
		return err
	}

	for k, v := range langMap {
		if k == "var" {
			continue
		}
		newFilename := strings.TrimSpace(k) + "_lang.h"
		newFilepath := filepath.Join(outDir, filepath.Base(newFilename))

		f, err := os.Create(newFilepath)
		if err != nil {
			return err
		}

		defer f.Close()

		headguardStr := (strings.ToUpper(strings.TrimSpace(k) + "_LANG_H"))

		writeStr := fmt.Sprintf(startText, newFilename, headguardStr, headguardStr)

		_, err = f.WriteString(writeStr)
		if err != nil {
			return err
		}

		// Actual localizations written here

		for i := 0; i < len(varNames); i++ {
			varNames[i] = strings.TrimSpace(varNames[i])
			varNames[i] = strings.ReplaceAll(varNames[i], " ", "_")
			varNames[i] = strings.ToUpper(varNames[i])
			if varNames[i] == "" {
				continue
			}

			if len(v) == i {
				break
			}

			writeStr = fmt.Sprintf(langText, varNames[i], v[i])

			_, err = f.WriteString(writeStr)
			if err != nil {
				return err
			}

		}

		// localization writing end

		writeStr = fmt.Sprintf(endText, headguardStr)

		_, err = f.WriteString(writeStr)
		if err != nil {
			return err
		}

		log.Println("Done generating:", newFilename)

	}

	return err
}

func CreateFilesMerge(langMap map[string][]string, outDir string, outFile string) (err error) {
	defer func() {
		if err != nil {
			err = fmt.Errorf("parsing records failed: %w", err)
		}
	}()

	outFile = strings.TrimSpace(outFile)

	fileInfo, err := os.Stat(outDir)
	if err != nil {
		err = fmt.Errorf("unable to get file information for %s %w", outDir, err)
		return err
	}

	if !fileInfo.IsDir() {
		err = fmt.Errorf("output path is not a directory %s", outDir)
		return err
	}

	if len(outFile) == 0 {
		err = fmt.Errorf("merged name specified cannot be empty %w", err)
		return err
	}

	if strings.Contains(outFile, ".") {
		err = fmt.Errorf("merged name specified cannot already have an extension %s", outDir)
		return err
	}

	varNames := langMap["var"]
	if len(varNames) == 0 {
		err = fmt.Errorf("no var fields assigned in input file")
		return err
	}

	//newSrcFilename := filepath.Join(outDir, filepath.Base(outFile+".c"))
	newHeaderFilename := outFile + ".h"
	newHeaderFilepath := filepath.Join(outDir, newHeaderFilename)

	f, err := os.Create(newHeaderFilepath)
	if err != nil {
		return err
	}

	defer f.Close()

	headguardStr := (strings.ToUpper(strings.TrimSpace(outFile) + "_H"))

	writeStr := fmt.Sprintf(startTextMerged, newHeaderFilename, headguardStr, headguardStr)

	_, err = f.WriteString(writeStr)
	if err != nil {
		return err
	}

	for k, v := range langMap {
		if k == "var" {
			continue
		}

		langOpt := strings.ToUpper(strings.TrimSpace(k))
		langOpt = strings.ReplaceAll(langOpt, " ", "_")

		writeStr = fmt.Sprintf(ifdefLangStartMerged, langOpt, langOpt)

		_, err = f.WriteString(writeStr)
		if err != nil {
			return err
		}

		// Actual localizations written here

		for i := 0; i < len(varNames); i++ {
			varNames[i] = strings.TrimSpace(varNames[i])
			varNames[i] = strings.ReplaceAll(varNames[i], " ", "_")
			varNames[i] = strings.ToUpper(varNames[i])
			if varNames[i] == "" {
				continue
			}

			if len(v) == i {
				break
			}

			writeStr = fmt.Sprintf(langText, varNames[i], v[i])

			_, err = f.WriteString(writeStr)
			if err != nil {
				return err
			}

		}

		writeStr = fmt.Sprintf(ifdefLangEndMerged, langOpt, langOpt)
		_, err = f.WriteString(writeStr)
		if err != nil {
			return err
		}

		log.Println("Done generating define for option:", langOpt)

	}

	// localization writing end

	writeStr = fmt.Sprintf(endTextMerged, headguardStr)
	_, err = f.WriteString(writeStr)
	if err != nil {
		return err
	}

	return err
}
