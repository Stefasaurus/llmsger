/*
Copyright Â© 2024 NAME HERE <EMAIL ADDRESS>
*/
package process

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"
)

const startText = `/** @file %s
* 
* @brief An automatically generated localization file. Generated by llmsger.
*/

#ifndef %s
#define %s

`

const endText = `
#endif /* %s */

/*** end of file ***/
`

const langText = "#define %s\t\t\"%s\"\n"

func CreateFiles(langMap map[string][]string, outDir string) (filesGen []string, err error) {
	defer func() {
		if err != nil {
			err = fmt.Errorf("parsing records failed: %w", err)
		}
	}()

	fileInfo, err := os.Stat(outDir)
	if err != nil {
		err = fmt.Errorf("unable to get file information for %s %w", outDir, err)
		return nil, err
	}

	if !fileInfo.IsDir() {
		err = fmt.Errorf("output path is not a directory %s %w", outDir, err)
		return nil, err
	}

	varNames := langMap["var"]
	if len(varNames) == 0 {
		err = fmt.Errorf("no var fields assigned in input file %w", err)
		return nil, err
	}

	for k, v := range langMap {
		newFilename := strings.TrimSpace(k) + "_lang.h"
		newFilepath := filepath.Join(outDir, filepath.Base(newFilename))

		f, err := os.Create(newFilepath)
		if err != nil {
			return nil, err
		}

		defer f.Close()

		headguardStr := (strings.ToUpper(strings.TrimSpace(k) + "_LANG_H"))

		writeStr := fmt.Sprintf(startText, newFilename, headguardStr, headguardStr)

		_, err = f.WriteString(writeStr)
		if err != nil {
			return nil, err
		}

		// Actual localizations written here

		for i := 0; i < len(varNames); i++ {
			varNames[i] = strings.TrimSpace(varNames[i])
			varNames[i] = strings.ReplaceAll(varNames[i], " ", "_")
			varNames[i] = strings.ToUpper(varNames[i])
			if varNames[i] == "" {
				continue
			}

			if len(v) == i {
				break
			}

			writeStr = fmt.Sprintf(langText, varNames[i], v[i])

			_, err = f.WriteString(writeStr)
			if err != nil {
				return nil, err
			}

		}

		// localization writing end

		writeStr = fmt.Sprintf(endText, headguardStr)

		_, err = f.WriteString(writeStr)
		if err != nil {
			return nil, err
		}

		log.Println("Done generating:", newFilename)

	}

	return filesGen, err
}
